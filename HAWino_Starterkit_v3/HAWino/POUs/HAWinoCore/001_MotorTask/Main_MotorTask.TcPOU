<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.13">
  <POU Name="Main_MotorTask" Id="{c0f79474-5394-49ee-95a0-09a934fd6952}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM Main_MotorTask
VAR
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Variablen, die zur Synchronisation über das PAI (Prozessabbild) in den Task geladen werden.
	// -> Die Variablen werden von anderen Tasks gesetzt und müssen in den Task In/Outputs verknüpft werden
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Inputs für die Regelung
	n1fromMotor AT%I* : UINT; //Geschwindigkeit von der Motorklemme über den InfoData Kanal
	n2fromMotor AT%I* : UINT;
	n3fromMotor AT%I* : UINT;
	currentfromMotor1 AT %I* : UINT;	//Strom von der Motorklemme über den InfoData Kanal 2
	currentfromMotor2 AT %I* : UINT;
	currentfromMotor3 AT %I* : UINT;
	sliderGripper AT %I* : BOOL;


	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Variablen werden zur Synchronisation über das PA-Q aus dem Task gesetzt.
	// -> Die Variablen werden von anderen Tasks gelesen.
	//////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Freigabe der Motoren
	enableToMotor1 AT%Q*:BOOL:=FALSE;
	enableToMotor2 AT%Q*:BOOL:=FALSE;
	enableToMotor3 AT%Q*:BOOL:=FALSE;
	//Sollwerte der Motoren
	velocityToMotor1 AT%Q*:INT:=0;
	velocityToMotor2 AT%Q*:INT:=0;
	velocityToMotor3 AT%Q*:INT:=0;
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Taskinterne Inputs
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Wheel-Encoder Daten
	wheelEncoderLocalVx AT%I*		:LREAL;
	wheelEncoderLocalVy AT%I*		:LREAL;
	wheelEncoderLocalVtheta AT%I*	:LREAL;
	// Bumper Daten
	bumper AT%I* : BOOL;
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Lokale Variablen
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Übergabevariablen vom Lageregler zum Drehzahlregler
	vXCartesianToMotors 	:	LREAL;
	vYCartesianToMotors 	:	LREAL;
	vThetaCartesianToMotors :	LREAL;
	//Reglerdaten
	Motor1current: INT;
	Motor2current: INT;
	Motor3current: INT;

	velWheel1: LREAL;
	velWheel2: LREAL;
	velWheel3: LREAL;	
	maxMotorRPM : INT := 3600; // in rpm 
	maxKlemmeDrehzahlMessung : LREAL := 10000; //Bei Maximaldrehzahl zurückgegebener Drehzahlwert der Motorklemme
	rWheel 		: INT := 40; //in mm
	ue			: LREAL := 0.0625; //Getriebeuebersetzung 
	cycletime : LREAL:= 0.00033333; //Cycletime des Motortasks
	enableMotorControl: BOOL;
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Instanzierung der FBs
	//////////////////////////////////////////////////////////////////////////////////////////////////////////

	FB_Drehzahlregler 	: FB_Drehzahlregler;	//Gilt für alle drei Motoren
	
	////////////////Neue Spielerei/////////////////
	toggle : BOOL := TRUE;
	toggle2 : BOOL := TRUE;
	timer : TON;
	timer_2 : TON;	

	rising1 : R_TRIG;
	rising2 : R_TRIG;
	
	W_X_targetSpeed: LREAL; 
	W_Y_targetSpeed: LREAL; 
	W_Theta_targetSpeed : LREAL; 
	R_X_targetSpeed: LREAL;
	R_Y_targetSpeed: LREAL;
	R_Theta_targetSpeed: LREAL;
	
	speedThreshold: LREAL := 0.01; //Annäherung nur aktiv bei Abweichung > threshold
	AccelerationRate: LREAL := 5; //Höhere Werte = höhere Beschleunigung
	
	//X_smoothnes : M_smothesAnnaehrn; 
	//y_smoothnes : M_smothesAnnaehrn;
	//Theta_smoothnes : M_smothesAnnaehrn;
	// -> LOL Methoden nicht istanzieren 
	
	Theta_smoothnes: INT;
	TestCase : INT := 1;
	// 0 = Bewegung x-Achse (---)
	// 1 = Bewegung x-Y-Achse (~~~~)
	// 2 = Bewegung x-Y-Achse + Rotatiom (~s~s~s)
	
	errorX: LREAL;
	targetPosX: LREAL;
	actualPosX: LREAL;
	errorY: LREAL;
	targetPosY: LREAL;
	actualPosY: LREAL;
	errorTheta: LREAL;
	targetPosTheta: LREAL;
	actualPosTheta: LREAL;
	diffConst: REAL;	
	IntegralX: LREAL;	
	IntegralY: LREAL;
	IntegralTheta: LREAL;
	PosTest: LREAL; 	

	KPX: REAL := 0.75;
	KPY: REAL:= 0.5;
	KPTheta: REAL := 0.3;
	KITheta: REAL := 0;
	KIY: REAL := 0;
	KIX: REAL := 0;	
	
	Threshold_NewPosition: LREAL := 50;
	PosArray : ARRAY[0..21] OF LREAL := [5500,3500,5500,2000,4000,2000,4000,3500,4000,2000,3000,2000,3000,3500,3000,2000,1500,2000,1500,3500,5500,3500];
	
	PositionNumber: INT := 0;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Umrechung der Klemmenwerte
ACT_Drehzahlerfassung();	
// Erste Zielposition

targetPosX := PosArray[PositionNumber];
targetPosY := PosArray[PositionNumber+1];
targetPosTheta := 0;

// Aktuelle Position des Roboters
actualPosX := Camera.cameraData.x2;
actualPosY := Camera.cameraData.y2;
actualPosTheta := Camera.cameraData.theta2;

// Testen ob die erste Zielpositon schon erreicht wurde und setzt sie auf die nächste, falls erreicht
IF ((ABS(actualPosX - targetPosX) < Threshold_NewPosition) AND (ABS(actualPosY - targetPosY) < Threshold_NewPosition) ) THEN
	PositionNumber := PositionNumber+2;
	targetPosX := PosArray[PositionNumber];
	targetPosY := PosArray[PositionNumber+1];
END_IF

enableMotorControl := TRUE;
errorX := targetPosX - actualPosX;
errorY := targetPosY - actualPosY;
errorTheta := -(targetPosTheta - actualPosTheta);

//Integratoren der Motoren
IntegralX := IntegralX + (errorX * diffConst);
IntegralY := IntegralY + (errorY * diffConst);
IntegralTheta := IntegralTheta + (errorTheta * diffConst);
//Zusammenführung der P und I Anteile der Motoren
W_X_targetSpeed := (errorX *KPX) + (KIX *IntegralX);
W_Y_targetSpeed := (errorY *KPY) + (KIY *IntegralY);
W_Theta_targetSpeed := (errorTheta *KPTheta) + (KITheta *IntegralTheta);

// Umrechnung von Welt in Motorcoordinaten
R_X_targetSpeed := W_X_targetSpeed * COS(actualPosTheta) - W_Y_targetSpeed * SIN(actualPosTheta);
R_Y_targetSpeed := W_Y_targetSpeed * COS(actualPosTheta) + W_X_targetSpeed * SIN(actualPosTheta);
R_Theta_targetSpeed := W_Theta_targetSpeed;

 //Smoothes Annähern an den Sollwert, anpassbar über integrationRate
// x Werte 
IF ABS(vXCartesianToMotors - R_X_targetSpeed) > speedThreshold THEN   
    IF vXCartesianToMotors < R_X_targetSpeed THEN
        vXCartesianToMotors := vXCartesianToMotors + AccelerationRate * 0.01;  //Beschleunigung vorwärts
    ELSE
        vXCartesianToMotors := vXCartesianToMotors - AccelerationRate * 0.01;  //Beschleunigung rückwärts
    END_IF
END_IF
// y Werte 
IF ABS(vYCartesianToMotors - R_Y_targetSpeed) > speedThreshold THEN   
    IF vYCartesianToMotors < R_Y_targetSpeed THEN
        vYCartesianToMotors := vYCartesianToMotors + AccelerationRate * 0.01;  //Beschleunigung vorwärts
    ELSE
        vYCartesianToMotors := vYCartesianToMotors - AccelerationRate * 0.01;  //Beschleunigung rückwärts
    END_IF
END_IF
// Theta Werte 
IF ABS(vThetaCartesianToMotors - R_Theta_targetSpeed) > speedThreshold THEN   
    IF vThetaCartesianToMotors < R_Theta_targetSpeed THEN
        vThetaCartesianToMotors := vThetaCartesianToMotors + AccelerationRate * 0.01;  //Beschleunigung vorwärts
    ELSE
       vThetaCartesianToMotors := vThetaCartesianToMotors - AccelerationRate * 0.01;  //Beschleunigung rückwärts
    END_IF
END_IF
FB_Drehzahlregler(targetVelX:= vXCartesianToMotors,
					targetVelY := vYCartesianToMotors, 
					tragetVelTheta:= vThetaCartesianToMotors,
					enable := enableMotorControl,
					bumper := bumper,
					MotorReset := FALSE,
					actualVelMotor1 := -velWheel1, 
					actualVelMotor2 := -velWheel2, 
					actualVelMotor3 := -velWheel3,
					enableToMotor1 => enableToMotor1,
					enableToMotor2 => enableToMotor2,
					enableToMotor3 => enableToMotor3,
					velocityToMotor1=> velocityToMotor1, 
					velocityToMotor2 => velocityToMotor2,
					velocityToMotor3 => velocityToMotor3);
				
				]]></ST>
    </Implementation>
    <Action Name="ACT_Drehzahlerfassung" Id="{fc784fde-e171-45e7-8902-8fc7a47aa187}">
      <Implementation>
        <ST><![CDATA[//Einlesen der Istwerte
//Motorstrom von der Klemme auslesen und umrechnen
Motor1current := UINT_TO_INT(currentfromMotor1);	//Umwandlung des Unsinged Integers in ein Integerwert
Motor2current := UINT_TO_INT(currentfromMotor2);
Motor3current := UINT_TO_INT(currentfromMotor3);

//Berechnung der Radgeschwindigkeit mit berücksichtigung des Getriebes
velWheel1 := -(UINT_TO_INT(n1fromMotor) / maxKlemmeDrehzahlMessung*maxMotorRPM/60*ue*2*PI*rWheel);
velWheel2 := -(UINT_TO_INT(n2fromMotor) / maxKlemmeDrehzahlMessung*maxMotorRPM/60*ue*2*PI*rWheel);
velWheel3 := -(UINT_TO_INT(n3fromMotor) / maxKlemmeDrehzahlMessung*maxMotorRPM/60*ue*2*PI*rWheel);]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>